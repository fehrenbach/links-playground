# Links port of the XPath code from
#
#   A Practical Theory of Language-Integrated Query
#   James Cheney, Sam Lindley, Philip Wadler
#   at ICFP'13

var db = database "stefan";

var xml = table ("xml") with
    (id : Int,
     parent : Int,
     name : String,
     pre : Int,
     post : Int) from db;

#typename QueryBuilder = ((pre: Int, post: Int)) {}-> [(|a::(Any,Base))];

typename Axis = [| Self
                 | Child
                 | Descendant
                 | DescendantOrSelf
                 | Following
                 | FollowingSibling
                 | Rev:Axis
                 |];

typename Path = [| Axis:Axis
                 | Seq:(Path, Path)
                 | Name:String
                 | Filter:Path
                 |];

typename XML = (id:Int,name:String,parent:Int,post:Int,pre:Int);

fun axis(ax) {
  switch (ax) {
    case Self -> fun (s, t) { s.id == t.id }
    case Child -> fun (s, t) { s.id == t.parent }
    case Descendant -> fun (s, t) { s.pre < t.pre && t.post < s.post }
    case DescendantOrSelf -> fun (s, t) { s.pre <= t.pre && t.post <= s.post }
    case Following -> fun (s, t) { s.post < t.pre }
    case FollowingSibling -> fun (s, t) { s.post < t.pre && s.parent == t.parent }
    case Rev(ax) -> var rev = axis(ax); fun (s, t) { rev(t, s) }
  }
}

#sig path : (Path, QueryBuilder) ~> QueryBuilder
sig path : (Path, (XML) {}-> [XML]) ~> (XML) {}-> [XML]
fun path(p, k) {
  switch (p) {
    case Seq(p, q) ->
      # Do the recursion outside to obtain a non-wild query function (note the {}-> type).
      var pq = path(p, path(q, k)) : ((XML) {}-> [XML]);
      # (Textually) substituting pq in the returned function for the right hand side does not work!
      fun (outer_context) {
          pq(outer_context)
      }
    case Axis(ax) ->
      var axisPredicate = axis(ax);
      fun (p) {
        for (c <-- xml)
        where (axisPredicate(p, c))
          k(c)
      }
    case Name(s) -> fun (p) {
       if (p.name == s) k(p) else []
    }
    case Filter(f) ->
      var k_f = path(f, fun (x) {[x]});
      fun (c) {
        for (x <-- xml)
        where (x.id == c.id && not(empty(k_f(x))))
          k(c)
      }
  }
}

# This should be identity, except for leaves, I think...
var crc = Seq(Axis(Child), Axis(Rev(Child)));

var xp7 = Seq(Axis(Child), Seq(Axis(Child), Axis(Child)));

var gce = Seq(Axis(Child), Seq(Axis(Child), Seq(Axis(Child), Name("e"))));

var xp0 = Seq(Axis(Child), Axis(Child));
var xp1 = Seq(Axis(DescendantOrSelf), Axis(Rev(Child)));
var xp2 = Seq(Axis(DescendantOrSelf), Filter(Seq(Axis(FollowingSibling), Name("d"))));
var xp3 = Seq(Axis(DescendantOrSelf),
              Seq(Name("f"),
                  Filter(Seq(Axis(Rev(DescendantOrSelf)),
                             Seq(Axis(Rev(Following)),
                                 Name("b"))))));

var xpmin = Seq(Axis(DescendantOrSelf),
              Filter(Seq(Axis(Child),
                         Axis(Child))));

var cf = path(Axis(Child), fun (x) {[x]});

var cf0 = path(xpmin, fun (x) {[x]});


query { for (r <-- xml)
        where (r.id == 0)
         cf0(r) }


# select (result."id") as "id",(result."name") as "name",(result."parent") as "parent",(result."post") as "post",(result."pre") as "pre"
#   from xml as root,
#        xml as result,
#        xml as filterbranch
#  where root."id" = 0
#    and root."pre" <= result."pre"
#    and result."post" <= root."post"
#    and result."name" = 'f'
#    and filterbranch."id" = result."id"
#    and exists (select 0 as dummy
#                  from xml as t1752,
#                       xml as t1753
# --                      , xml as t1746 -- this line is missing for some reason...
#                 where t1746."pre" <= filterbranch."pre" and filterbranch."post" <= t1746."post" and t1753."post" < t1746."pre" and t1753."name" = 'b')

#var xpmin = Seq(Axis(DescendantOrSelf),
#              Filter(Seq(Axis(Child),
#                         Axis(Child))));

# //*[child::*/child::*]

# select (result."id") as "id",(result."name") as "name",(result."parent") as "parent",(result."post") as "post",(result."pre") as "pre"
#   from xml as root,
#        xml as result,
#        xml as t1746
#  where root."id" = 0
#    and root."pre" <= result."pre"
#    and result."post" <= root."post"
#    and t1746."id" = result."id"
#    and exists (select 0 as dummy
#                  from xml as t1753, -- t1753 is never used, and 1747 is never introduced!
#                       xml as t1754
#                 where t1746."id" = t1747."parent"
#                   and t1747."id" = t1754."parent")
